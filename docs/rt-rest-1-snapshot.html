<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>REST - Request Tracker Wiki</title>
<meta name="viewport" content="width=1000">
<style>
body {
    font-family: serif;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    line-height: 1.6;
}
pre {
    background-color: #f5f5f5;
    border: 1px solid #ddd;
    padding: 10px;
    overflow-x: auto;
}
code {
    background-color: #f5f5f5;
    padding: 2px 4px;
    border-radius: 3px;
}
.toc {
    background-color: #f9f9f9;
    border: 1px solid #aaa;
    display: table;
    margin-bottom: 1em;
    padding: 1em;
}
.toc ul {
    list-style-type: none;
}
table {
    border-collapse: collapse;
    width: 100%;
}
th, td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
}
th {
    background-color: #f2f2f2;
}
</style>
</head>
<body>

<h1>REST</h1>

<div class="toc">
<h2>Contents</h2>
<ul>
<li><a href="#Abstract">1 Abstract</a></li>
<li><a href="#Interface">2 Interface</a>
<ul>
<li><a href="#Authentication">2.1 Authentication</a></li>
<li><a href="#Ticket">2.2 Ticket</a>
<ul>
<li><a href="#Ticket_Properties">2.2.1 Ticket Properties</a></li>
<li><a href="#Ticket_Links">2.2.2 Ticket Links</a></li>
<li><a href="#Ticket_Attachments">2.2.3 Ticket Attachments</a></li>
<li><a href="#Ticket_Attachment">2.2.4 Ticket Attachment</a></li>
<li><a href="#Ticket_Attachment_Content">2.2.5 Ticket Attachment Content</a></li>
<li><a href="#Ticket_History">2.2.6 Ticket History</a></li>
<li><a href="#Ticket_History_Entry">2.2.7 Ticket History Entry</a></li>
<li><a href="#Ticket_Search">2.2.8 <b>Ticket Search</b></a></li>
<li><a href="#Ticket_Create">2.2.9 <b>Ticket Create</b></a></li>
<li><a href="#Ticket_Edit">2.2.10 Ticket Edit</a></li>
<li><a href="#Tickets_History_Reply">2.2.11 Tickets History Reply</a></li>
<li><a href="#Ticket_History_Comment">2.2.12 Ticket History Comment</a></li>
<li><a href="#Ticket_Links_Edit">2.2.13 Ticket Links Edit</a></li>
<li><a href="#Ticket_Merge">2.2.14 Ticket Merge</a></li>
</ul>
</li>
<li><a href="#User_Properties">2.3 User Properties</a></li>
<li><a href="#User">2.4 User</a></li>
<li><a href="#Queue">2.5 Queue</a></li>
<li><a href="#Logout">2.6 Logout</a></li>
</ul>
</li>
<li><a href="#Types">3 Types</a></li>
<li><a href="#Miscellaneous">4 Miscellaneous</a></li>
<li><a href="#Examples">5 Examples</a></li>
<li><a href="#Convenience_libraries">6 Convenience libraries</a></li>
</ul>
</div>

<h2 id="Abstract">Abstract</h2>
<p>The REST Interface gives you access to your RT Database. The complete communication is encapsulated in the HTTP protocol. The interface should be accessible in your installation.
</p><p>Though you may see references to older 3.x releases of RT below, the REST 1.0 interface has not changed in any significant way in 4.x.
</p><p>This page is for REST version 1.0. 
</p><p>The next version of the RT REST interface, version 2.0, is available as an extension for RT 4.4 and above. 
</p><p>REST2 is core in RT 5.0.0 and above.
</p>

<h2 id="Interface">Interface</h2>
<p>Base URL: <code>.../REST/1.0/</code>. The default response should be:
</p>
<pre>   RT/3.4.5 200 Ok
</pre>
<pre>   # Invalid object specification: 'index.html'
</pre>
<pre>   id: index.html
</pre>

<h3 id="Authentication">Authentication</h3>
<p>The REST Interface does not support HTTP-Authentication. So you must get a valid Session-Token and submit the cookie each request. You usually get a Session-Cookie by submitting the default login form. Use variables "<code>user</code>" for login and "<code>pass</code>" for password values. wget doesn't escape any characters in the --post-data option so make sure you properly escape any special characters in the password.
</p><p>See the wget invocation line below:
</p>
<pre>   wget  --keep-session-cookies \
   --save-cookies cookies.txt \
   --post-data 'user=UUUU&amp;pass=PPPP' \
   http://my.rt.server
</pre>
<p>You need the -keep-session-cookies option to make wget save session cookies.
</p>

<h3 id="Ticket">Ticket</h3>
<h4 id="Ticket_Properties">Ticket Properties</h4>
<p>Gets the data for a single ticket, not including the history and comments.
</p><p>Request: <code>/REST/1.0/ticket/&lt;ticket-id&gt;/show</code>
</p>
<pre>RT/3.4.5 200 Ok

id: ticket/&lt;ticket-id&gt;
Queue: &lt;...&gt;
Owner: &lt;...&gt;
Creator: &lt;...&gt;
Subject: &lt;...&gt;
Status: &lt;...&gt;
Priority: &lt;...&gt;
InitialPriority: &lt;...&gt;
FinalPriority: &lt;...&gt;
Requestors: &lt;...&gt;
Cc: &lt;...&gt;
AdminCc: &lt;...&gt;
Created: &lt;...&gt;
Starts: &lt;...&gt;
Started: &lt;...&gt;
Due: &lt;...&gt;
Resolved: &lt;...&gt;
Told: &lt;...&gt;
TimeEstimated: &lt;...&gt;
TimeWorked: &lt;...&gt;
TimeLeft: &lt;...&gt;
</pre>

<h4 id="Ticket_Links">Ticket Links</h4>
<p>Gets the ticket links for a single ticket.
</p><p>Request: <code>REST/1.0/ticket/&lt;ticket-id&gt;/links/show</code>
</p>
<pre>RT/3.8.2 200 Ok

id: ticket/&lt;ticket-id&gt;/links
HasMember: fsck.com-rt://your.server.com/ticket/&lt;another-id&gt;
ReferredToBy: fsck.com-rt://your.server.com/ticket/&lt;another-id&gt;
DependedOnBy: fsck.com-rt://your.server.com/ticket/&lt;another-id&gt;
MemberOf: fsck.com-rt://your.server.com/ticket/&lt;another-id&gt;
RefersTo: fsck.com-rt://your.server.com/ticket/&lt;another-id&gt;
DependsOn: fsck.com-rt://your.server.com/ticket/&lt;another-id&gt;
</pre>

<h4 id="Ticket_Attachments">Ticket Attachments</h4>
<p>Gets a list of all attachments related to the ticket
</p><p>Request: <code>/REST/1.0/ticket/&lt;ticket-id&gt;/attachments</code>
</p>

<h4 id="Ticket_Attachment">Ticket Attachment</h4>
<p>Gets the metadata and content of a specific attachment.
</p><p>Request: <code>/REST/1.0/ticket/&lt;ticket-id&gt;/attachments/&lt;attachment-id&gt;</code>
</p>
<pre>RT/3.8.0 200 Ok
 
id: &lt;attachment-id&gt;
Subject:
Creator: &lt;user-id&gt;
Created: &lt;timestamp&gt;
Transaction: &lt;transaction-id&gt;
Parent: &lt;parent-id&gt;
MessageId:
Filename: &lt;filename&gt;
ContentType: application/octet-stream
ContentEncoding: none
 
Headers: MIME-Version: 1.0
         X-Mailer: MIME-tools 5.427 (Entity 5.427)
         Content-Type: application/octet-stream;
           name="&lt;filename&gt;"
         Content-Disposition: inline; filename="&lt;filename&gt;"
         Content-Transfer-Encoding: base64
         Content-Length: &lt;length in bytes&gt;

Content: ...
         ...
         ...
</pre>
<p><i>NOTE: RT returns the content indented with 9 spaces on each line, so that it lines up with the "Content:" header. Even if you strip this out with a regexp, the content is still UTF-8, which is probably not what you want. To get the original binary data back, strip out the 9 spaces with a regexp, strip off the 3 carriage returns at the end, and then convert the whole thing from UTF-8 to the native character encoding of the attachment, whatever that is. RT doesn't tell you, so you have know. If the attachments were uploaded by a U.S. Windows system, odds are that Windows-1252 is what you want. If you can't get the binary back intact, see the next method below.</i>
</p>

<h4 id="Ticket_Attachment_Content">Ticket Attachment Content</h4>
<p>Gets the attachment data content without additional metadata or whitespace characters
</p><p>Request: <code>/REST/1.0/ticket/&lt;ticket-id&gt;/attachments/&lt;attachment-id&gt;/content</code>
</p>
<pre>RT/3.8.0 200 Ok

...
...
...
</pre>
<p>So to get the original content you still have to strip the first 2 lines of the response.
</p>

<h4 id="Ticket_History">Ticket History</h4>
<p>Gets a list of all the history items for a given ticket.
</p><p>Request: <code>/REST/1.0/ticket/&lt;ticket-id&gt;/history</code>
</p>
<pre>RT/3.4.5 200 Ok

# &lt;history-count&gt;/&lt;history-count&gt; (/total)

&lt;history-id&gt;: &lt;history-name&gt;
&lt;history-id&gt;: &lt;history-name&gt;
...
</pre>
<p>You will get an additional row, for each history entry found. The first entry is usually: "<code>Ticket created by ...</code>".
</p><p>There are two ways to get history item detail: you can do one of these and then recursively perform <code>ticket/history/id/&lt;history-id&gt;</code> for each history-id from this REST call, but that is extremely wasteful and will scale horribly. What you really want to do is one REST call but get the long format:
</p><p>Request: <code>/REST/1.0/ticket/&lt;ticket-id&gt;/history?format=l</code>
</p>
<pre>RT/3.8.2 200 Ok

# &lt;n&gt;/&lt;n&gt; (id/&lt;history-id&gt;/total)

id: &lt;history-id&gt;
Ticket: &lt;ticket-id&gt;
TimeTaken: &lt;...&gt;
Type: &lt;...&gt;
Field: &lt;...&gt;
OldValue: &lt;...&gt;
NewValue: &lt;...&gt;
Data: &lt;...&gt;
Description: &lt;...&gt;
Content: &lt;...&gt;
Creator: &lt;...&gt;

Created: &lt;...&gt;

Attachments:
             &lt;attachment-id&gt;: &lt;filename&gt; (&lt;size&gt;)
             &lt;attachment-id&gt;: &lt;filename&gt; (&lt;size&gt;)

--

# &lt;n&gt;/&lt;n&gt; (id/&lt;history-id&gt;/total)
...
</pre>
<p><i>NOTE: the double dash "--" will occur in the long format between each history item. You can split the output on "--" and iterate over it, parsing out the data with an RFC822 parser, such as an email handling library.</i>
</p>

<h4 id="Ticket_History_Entry">Ticket History Entry</h4>
<p>Gets the history information for a single history item. Note that the history item must actually correspond to the ticket.
</p><p>Request: <code>/REST/1.0/ticket/&lt;ticket-id&gt;/history/id/&lt;history-id&gt;</code>
</p>
<pre>RT/3.4.5 200 Ok

# 70/70 (id/114856/total)

id: &lt;history-id&gt;
Ticket: &lt;ticket-id&gt;
TimeTaken: &lt;...&gt;
Type: &lt;...&gt;
Field: &lt;...&gt;
OldValue: &lt;...&gt;
NewValue: &lt;...&gt;
Data: &lt;...&gt;
Description: &lt;...&gt;

Content: &lt;lin1-0&gt;
         &lt;line-1&gt;
         ...
         &lt;line-n&gt;
         
Creator: &lt;...&gt;
Created: &lt;...&gt;
Attachments: &lt;...&gt;
</pre>
<p><i>IMPORTANT NOTE: At least with RT 3.8.0, when you request a history item with this method AND you have attached a file that has Mime type text/plain to the same item (eg. a comment with an attachement), RT will return the complete content of the attachment for the key "Content:" and not your real comment that you can see in the web frontend. This may lead to some problems if the requestor does not expect to get a comment content that is for example 1.8 MB of text. With other Mime type attachments this however seems to work. I don't know if this is a feature or a bug.</i>
</p>

<h4 id="Ticket_Search"><b>Ticket Search</b></h4>
<p>Request: <code>/REST/1.0/search/ticket?query=&lt;query&gt;&amp;orderby=&lt;sort-order&gt;&amp;format=&lt;format&gt;</code>
</p><p><b>Parameters</b>
</p><p><b>query</b>
</p><p>You can use any query generated by the query builder - or feel free to write your own. Here an example that will do the following: Find all tickets that have no owner and the status new or open
</p><p><code>query= Owner = 'Nobody' AND ( Status = 'new' OR Status = 'open' )</code>
</p><p>Example: to get all the tickets in "fooQueue" you'd access:
</p>
<pre><code>/REST/1.0/search/ticket?query=Queue='fooQueue'</code>
</pre>
<p>Example: to get the tickets for a custom field "Contact Name" you'd access:
</p>
<pre><code>/REST/1.0/search/ticket?query='CF.{Contact Name}'='Shaun Wallace'</code>
</pre>
<p><br />
<b>orderby</b>
</p><p>By this parameter you can change the sort field and order of the search result. To sort a list ascending just put a + before the fieldname, otherwise a -. Eg: -Created (will put the newest tickets at the beginning).
</p><p>Example:
</p>
<pre><code>/REST/1.0/search/ticket?query=Queue='fooQueue'&amp;orderby=+Created</code>
</pre>
<p><br />
<b>format</b>
</p>
<ul><li>i: ticket/&lt;ticket-id&gt;</li>
<li>s: &lt;ticket-id&gt;: &lt;ticket-subject&gt;</li>
<li>l: a multi-line format (Full ticket details without content)</li></ul>
<p>Example:
</p>
<pre><code>/REST/1.0/search/ticket?query=Queue='fooQueue'&amp;orderby=+Created&amp;format=i</code>
</pre>
<p><b>fields</b>
</p><p>A list of fields you would like included in the result set.
</p><p>Example:
</p>
<pre><code>/REST/1.0/search/ticket?query=id=42&amp;format=l&amp;fields=Subject,Status,Priority,CF.\{Category\}</code>
</pre>
<p>Note that you may need to escape characters like the curly braces for CFs.
</p>

<h4 id="Ticket_Create"><b>Ticket Create</b></h4>
<p>To create a new ticket: post on <code>/REST/1.0/ticket/new</code> with a variable named "<code>content</code>",
</p><p>containing "<code>key: value</code>" line by line, example:
</p><p>Testing the new ticket section
</p>
<pre>id: ticket/new
Queue: &lt;queue name&gt;
Requestor: &lt;requestor email address&gt;
Subject: &lt;subject&gt;
Cc: &lt;...&gt;
AdminCc: &lt;...&gt;
Owner: &lt;...&gt;
Status: &lt;...&gt;
Priority: &lt;...&gt;
InitialPriority: &lt;...&gt;
FinalPriority: &lt;...&gt;
TimeEstimated: &lt;...&gt;
Starts: &lt;...&gt;
Due: &lt;...&gt;
Text: &lt;The ticket content&gt;
CF-&lt;CustomFieldName&gt;: &lt;CustomFieldValue&gt;
</pre>
<p>If there are any "special" characters (Umlauts, dash, ...?) in a custom field's name, you can still access it via its ID:
</p>
<pre>CF-$id: &lt;Value&gt;
</pre>
<p>If you want to have a multiline Text, prefix every line with a blank.
</p>
<pre>Due: &lt;...&gt;
Text: This is 
 a 
 multiline Text
!!!
CF-&lt;CustomFieldName&gt;: &lt;CustomFieldValue&gt;
</pre>
<p>The response should look like: 
</p>
<pre>RT/4.0.6 200 Ok

# Ticket 775 created.
</pre>

<h5 id="curl_example">curl example</h5>
<pre> * Create a file containing the ticket form:
</pre>
<pre>id: ticket/new
Queue: queue1
Requestor: requestor@email
Priority: 4
CF-Type of request: Demande
Subject: Test REST
Text: Multi line
 test with
 special chars: é
</pre>
<pre> * Submit using curl:
</pre>
<pre>curl --data-urlencode content@file.name 'https://HOSTNAME/REST/1.0/ticket/new?user=USER&amp;pass=PASSWORD'
</pre>

<h4 id="Ticket_Edit">Ticket Edit</h4>
<p>To update an existing ticket: post on <code>/REST/1.0/ticket/&lt;ticket-id&gt;/edit</code> with a variable named "content", containing "key: value" line by line (like the one displayed when issuing <code>ticket/&lt;ticket-id&gt;/show</code>). Example:
</p>
<pre>Priority: 5
TimeWorked: 15
</pre>

<h4 id="Tickets_History_Reply">Tickets History Reply</h4>
<p>Same as comment: post on <code>/REST/1.0/ticket/&lt;ticket-id&gt;/comment</code> with a variable name <code>content</code>, containing "<code>key: value</code>" line by line:
</p>
<pre>id: &lt;ticket-id&gt;
Action: correspond
Text: the text comment
Cc: &lt;...&gt;
Bcc: &lt;...&gt;
TimeWorked: &lt;...&gt;
Attachment: an attachment filename/path
</pre>
<p><code>Cc</code> and <code>Bcc</code> are for this reply only (<i>I think</i>).
</p>

<h4 id="Ticket_History_Comment">Ticket History Comment</h4>
<p>To add a comment to an existing ticket: POST on "<code>/REST/1.0/ticket/&lt;ticket-id&gt;/comment</code>" with a variable name "<code>content</code>", containing "<code>key: value</code>" line by line:
</p>
<pre>id: &lt;ticket-id&gt;
Action: comment
Text: the text comment
Attachment: an attachment filename/path
</pre>
<p>Action can be "<code>comment</code>" or "<code>correspond</code>". For a list of fields you can use in correspondence, try "<code>/opt/rt3/bin/rt correspond ticket/1</code>"
</p><p>If your comment contains multiple lines, each new line must be preceded by a space (e.g. "line 1\n line 2").
</p><p>
If you want to use HTML replies, use </p><pre>Content-Type: text/html</pre>
<p>If you used "<code>Attachment</code>", you must add to your POST a variable "<code>attachment_1</code>" that contains the raw attachment in multi-part file object.
</p><p>You can upload more attachments as well, in this case you have to separate the file names in the "<code>Attachment</code>" with "\n "(a newline and space, without quotes) and add a new variable "attachment_$i" to your POST where $i is the index of attachment.
</p><p>You need to send header to post comments
</p>

<h4 id="Ticket_Links_Edit">Ticket Links Edit</h4>
<p>To update links on an existing ticket: POST on "<code>/REST/1.0/ticket/&lt;ticket-id&gt;/links</code>" with a variable named "<code>content</code>", containing "<code>key: value</code>" line by line (like the one displayed when issuing "<code>ticket/&lt;ticket-id&gt;/links</code>"). Example:
</p>
<pre>DependsOn: 54354
RefersTo: http://some.external/link
</pre>

<h4 id="Ticket_Merge">Ticket Merge</h4>
<p>To merge tickets: POST on "<code>/REST/1.0/ticket/&lt;origin-ticket-id&gt;/merge/&lt;into-ticket-id&gt;</code>". (I don't think any content is required, but I send "id" and "into" anyway.)
</p>

<h3 id="User_Properties">User Properties</h3>
<p>Gets the data for a single user.
</p><p>Request: <code>/REST/1.0/user/&lt;user-id&gt;</code>
</p>
<pre>RT/3.8.4 200 Ok

id: user/&lt;user-id&gt;
Name: &lt;...&gt;
Password: ********
EmailAddress: &lt;...&gt;
RealName: &lt;...&gt;
Organization: &lt;...&gt;
Privileged: &lt;...&gt;
Disabled: &lt;...&gt;
</pre>
<p>Also you can use user login instead of user ID.
</p>

<h3 id="User">User</h3>
<h4 id="User_Create">User Create</h4>
<p>To create a new user: post on <code>/REST/1.0/user/new</code> with a variable named "<code>content</code>", containing "<code>key: value</code>" line by line, like the response to <code>/user/&lt;ticket-id&gt;</code>
</p>
<h4 id="User_Edit">User Edit</h4>
<p>To update an existing user: post on <code>/REST/1.0/user/&lt;user-id&gt;/edit</code> with a variable named "content", containing "key: value" line by line (like the one displayed when issuing <code>user/&lt;user-id&gt;/show</code>).
</p>

<h3 id="Queue">Queue</h3>
<p>Search for all queues mail addresses like thist:
</p>
<pre> /REST/1.0/search/queue?query=\&amp;fields=CorrespondAddress,CommentAddress
</pre>
<h4 id="Single_queue_properties">Single queue properties</h4>
<p>Gets the data for a single queue.
</p><p>Request: <code>/REST/1.0/queue/&lt;queue-id&gt;</code>
</p>
<pre>RT/3.8.4 200 Ok

id: queue/&lt;queue-id&gt;
Name: &lt;...&gt;
Description: &lt;...&gt;
 CorrespondAddress: &lt;...&gt;
CommentAddress: &lt;...&gt;
InitialPriority: &lt;...&gt;
FinalPriority: &lt;...&gt;
DefaultDueIn: &lt;...&gt;
</pre>

<h3 id="Logout">Logout</h3>
<p>To logout: post on <code>/REST/1.0/logout</code> with empty content.
</p>

<h2 id="Types">Types</h2>
<ul><li>new</li>
<li>open</li>
<li>stalled</li>
<li>resolved</li>
<li>rejected</li>
<li>deleted</li></ul>
<p>+ other custom values defined in you local RT portal.
</p>

<h3 id="History_entry_type">History entry type</h3>
<ul><li>Create</li>
<li>CustomField</li>
<li>EmailRecord</li>
<li>Status</li>
<li>CommentEmailRecord</li>
<li>Correspond</li>
<li>Comment</li>
<li>Priority</li>
<li>Give</li>
<li>Steal</li>
<li>Take</li>
<li>Untake</li>
<li>AddWatcher</li>
<li>DeleteWatcher</li>
<li>AddLink</li>
<li>DeleteLink</li>
<li>AddReminder</li>
<li>OpenReminder</li>
<li>ResolveReminder</li>
<li>Set</li>
<li>Force</li>
<li>Subject</li>
<li>Told</li>
<li>PurgeTransaction</li></ul>

<h2 id="Miscellaneous">Miscellaneous</h2>
<h3 id="Data_format">Data format</h3>
<ul><li>History entries time returns in UTC, boolean returns as <code>1</code> (true) and <code>0</code>(false).</li></ul>
<ul><li>Use only <code>"\n"</code>, not <code>"\r\n"</code>in post content.</li></ul>
<ul><li>Comments in response body starts with with a hash (<code>#</code>) symbol.</li></ul>

<h3 id="Request_status">Request status</h3>
<p>To get real request/post status you need to check status code in first line of server response.
</p>

<h2 id="Examples">Examples</h2>
<h3 id="Perl">Perl</h3>
<p>To get the results of a single request (without setting the Session-Cookie) - assuming you've set:
</p>
<ul><li>$uri to your RT REST URL</li>
<li>$access_user to your username</li>
<li>$access_password to your password</li>
<li>$ticketNumber to the ticket you want to see</li></ul>
<pre>my $ua = LWP::UserAgent-&gt;new;
$ua-&gt;timeout(10);
$ua-&gt;agent("YOURUSERAGENTHERE");
 
my $response = $ua-&gt;post($uri."ticket/$ticketNumber",
   ['user' =&gt; $access_user, 'pass' =&gt; $access_password],
    'Content_Type' =&gt; 'form-data');

if ($response-&gt;is_success) {
   print $response-&gt;decoded_content;
}
</pre>

<h3 id="Java">Java</h3>
<pre>import java.io.IOException;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.methods.PostMethod;
import org.apache.commons.httpclient.methods.multipart.MultipartRequestEntity;
import org.apache.commons.httpclient.methods.multipart.Part;
import org.apache.commons.httpclient.methods.multipart.StringPart;
  
public class RtTicketCreator {
   static final String BASE_URI = "http://rt.xxx.com/REST/1.0";
 
   public static void main(String[] args) throws IOException {
 
      PostMethod mPost = new PostMethod(BASE_URI + "/ticket/new?user=username&amp;pass=password");
      Part[] parts = { new StringPart("content", "Queue: General\nSubject: 123") };
      mPost.setRequestEntity(new MultipartRequestEntity(parts, mPost.getParams()));
      HttpClient cl = new HttpClient();
      cl.executeMethod(mPost);
      System.out.println(mPost.getResponseBodyAsString());
   }
}
</pre>

<h3 id="Python">Python</h3>
<pre>import cookielib
import urllib
import urllib2
       
  # creates a cookie for the rtserver with the credentials given at initialization.
  # define your credentials here
access_user = 'your_login'
access_password = 'your_password'
       
 # here is the RequestTracker URI we try to access
uri = 'http://your-rt-instance.com/REST/1.0/'
       
 # trying login on rt server
cj = cookielib.LWPCookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
urllib2.install_opener(opener)
data = {'user': access_user, 'pass': access_password}
ldata = urllib.urlencode(data)
login = urllib2.Request(uri, ldata)
try:
   response = urllib2.urlopen(login)
   print response.read()
   print "login successful"
except urllib2.URLError:
   # could not connect to server
   print "Not able to login"
</pre>

<h3 id="Ruby">Ruby</h3>
<pre>#!/usr/bin/env ruby
require 'net/http'

user = 'username'
pass = 'password'
uri = URI('https://rt.example.com/REST/1.0/ticket/123/show')

req = Net::HTTP::Post.new(uri.path)
req.set_form_data('user' =&gt; user, 'pass' =&gt; pass)

res = Net::HTTP.start(uri.hostname, uri.port, 
  :use_ssl =&gt; uri.scheme == 'https', 
  :set_debug_output =&gt; $stderr) do |http|
  http.request(req)
end

case res
when Net::HTTPSuccess, Net::HTTPRedirection
  # OK
  puts "HTTP response code:  #{res.code}"
  puts "HTTP message: #{res.message}"
  puts "Response:"

  res.each do |key,val|
    puts "#{key} =&gt; #{val}"
  end

  puts "Data:"
  puts res.body
else
  res.value
end
</pre>

<h2 id="Convenience_libraries">Convenience libraries</h2>
<p>There are libraries which do much of the low-level work shown in the examples below for you, and provide an easier programming interface for dealing with RT:
</p>
<table>
<tr>
<th>Language</th>
<th>Package/Module</th>
<th>Example</th>
<th>Note</th>
</tr>
<tr>
<td><b>Perl</b></td>
<td>RT::Client::REST</td>
<td><code>"perl -MCPAN -e install RT::Client::REST"</code></td>
<td></td>
</tr>
<tr>
<td><b>Ruby</b></td>
<td>rt-client</td>
<td><code>gem install rt-client</code></td>
<td></td>
</tr>
<tr>
<td><b>Ruby</b></td>
<td>Roart</td>
<td><code>gem install roart</code></td>
<td></td>
</tr>
<tr>
<td><b>Python</b></td>
<td>rtapi</td>
<td><code>pip install rtapi</code></td>
<td></td>
</tr>
<tr>
<td><b>Python</b></td>
<td>rtkit</td>
<td><code>pip install python-rtkit</code></td>
<td></td>
</tr>
<tr>
<td><b>Python</b></td>
<td>python-rt</td>
<td><code>pip install rt</code></td>
<td></td>
</tr>
<tr>
<td><b>Java</b></td>
<td>RT-REST</td>
<td><code>N/A</code></td>
<td></td>
</tr>
<tr>
<td><b>PHP</b></td>
<td>RTPHPLib</td>
<td>composer require dersam/rt-php-lib</td>
<td></td>
</tr>
</table>

<hr>
<p><small>
<strong>Attribution:</strong> This content is derived from the <a href="https://rt-wiki.bestpractical.com/wiki/REST">Request Tracker Wiki</a> maintained by Best Practical Solutions.<br>
Snapshot created: August 9, 2025<br>
Original content licensed under <a href="https://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported</a>
</small></p>

</body>
</html>